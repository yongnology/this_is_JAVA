----------------------------------------------
chapter 02 변수와 타입
----------------------------------------------

2.1 변수

변수란
- 하나의 값을 저장할 수 있는 메모리 공가닝다.
- 변수의 첫 번째 글자는 문자이거나 $ _ 이어야 하며
  숫자로 시작할 수 없다.
- 선언된 블록 내에서만 사용이 가능하다.

----------------------------------------------

2.2 데이터 타입

정수 타입 : byte, char, shortm int, long
실수 타입 : float, double
논리 타입 : boolean

자바는 기본적으로 정수 연산을 int 타입으로 실행한다.

String
- 클래스 타입이고, String 변수는 참조 변수이다.
- 문자열 String 변수에 대입하면 String 객체가 생성되고,
  String 변수는 String 객체의 번지를 참조하게 된다.

----------------------------------------------

2.3 타입 변환

■ 타입 변환
데이터 타입을 다른 데이터 타입으로 변환하는 것을 말한다.

■ 자동 타입 변환
  : 프로그램 실행 도중에 작은 타입은 큰 타입으로 자동 타입 변환된다.

■ 강제 타입 변환(캐스팅 : Casting)
  : 큰 타입을 작은 타입 단위로 쪼개고 끝 한부분만 작은 타입으로 강제적 변환한다.
	ex) 작은 크기 타입 = (작은크기타입) 큰 크기 타입
	ex)
	long longValue = 300;
	int intValue = (int)long Value;	// 정상 저장이 된다.

■ 연산식에서 자동 타입 변환
  : 연산은 같은 타입의 피연산자(operand)간에만 수행한다.
	- 서로 다른 타입의 피연산자는 같은 타입으로 변환됨.
	- 두 피연산자 중 크기가 큰 타입으로 자동 변환

----------------------------------------------
chapter 03 연산자
----------------------------------------------

3.1 연산자와 연산식

연산
- 데이터를 처리하여 결과를 산출하는 것
- 연산자(Operations) : 연산에 사용되는 표시나 기호
- 피연산자(Operand) : 연산 대상이 되는 데이터(리터럴, 변수)
- 연산식(Expression) : 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것

----------------------------------------------

3.2 연산의 방향과 우선순위

■ 우선 순위 정리
1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다.
2. 산술, 비교, 논리, 대입 여산자 순으로 우선순위를 가진다.
3. 단항과 대입 연산자르 제외한 모든 연산자의 방향은 왼쪽에서 오른쪽이다.
4. 복잡한 연산식에는 괄호()사용해서 우선순위를 정해준다.

----------------------------------------------

3.3 단항 연산자

■ 단항 연산자
  : 피연산자가 1개인 연산자
- 종류
	- 부호 연산자 : ++
	- 증감 연산자 : ++, --
	- 부정 연산자 : !
	- 비트 반전 연산자 : ~

----------------------------------------------

3.4 이항 연산자

■ 이항 연산자
  : 피연산자가 2개인 연산자
- 종류
	- 산술 연산자 : +, - *, /, %
	- 문자열 연결 연산자 : +
	- 대입 연산자 : =, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=
	- 비교 연산자 : <, <=, >, >=, ==, !=
	- 논리 연산자 : &&, ||, &, |, ^, !
	
	■ 비트 연산자
	: 비트(bit)단위로 연산을 한다. 즉 0과 1이 피연산자가 된다.
	- 비트 논리 연산자 : &, |, ^
	- 비트 이동 연산자 : <<, >>, >>>

- 오버플로우
  : 산술 연산을 할 때에는 산출값이 산출 타입으로 충분히 표현 가능한지 살펴봐야 한다.

- 정확한 계산은 정수를 사용한다.

- String 타입의 문자열을 비교할 때에는 대소 연산자를 사용할 수 없다.
- 문자열 비교는  equals() 메소드를 사용해야 한다.

----------------------------------------------

3.5 삼항 연산자

조건 연산식( ()? : )
	조건식	 ? 	값 또는 연산식	:	값 또는 연산식
	(피연산자1) 	(피연산자2)		 (피연산자3)

----------------------------------------------
chapter 04 조건문과 반복문
----------------------------------------------

4.1 코드 실행 제어

■ 정상적인 코드 실행 흐름
  : main() 메소드의 시작 중괄호 {에서 끝 중괄호 }까지
    위에서 아래 방향으로 실행

■ 제어문의 역할
  : 정상적인 코드 실행 흐름을 개발자가 원하는 방향으로 변경할 수 있도록 한다.

■ 제어문의 종류
	1) 조건문 : if문, switch문
	2) 반복문	: for문, while문, do-while문
	3) break문, continue문

----------------------------------------------

4.2 조건문(if문, switch문)

■ if문
  : 조건식의 결과에 따라 중괄호 {} 블록을 실행할지 여부를 결정할 때 사용

■ if-else문
  : 조건식의 결과에 다라 실행 블록을 선택한다.

■ if-else if-else문
  : 복수의 조건식을 두어 조건식을 만족하는 블록만 실행한다.

■ 중첩 if문
  : if문의 블록 내부에는 또 다른 if문을 사용할 수 있다.

■ switch문
  : 변수나 연산식의 값에 따라 실행문을 선택할 때 사용한다.

----------------------------------------------

4.3 반복문(for문, while문, do-while문)

■ 반복문
  : 중괄호 블록 내용을 반복적으로 실행할 때 사용한다.

- for 문 : 반복 횟수를 알고 있을 때 주로 사용

- while 문 : 조건에 따라 반복을 계속할지를 결정할 때 사용

- do-while문 : 블록 내부의 실행문을 우선 실행하고
  실행 결과에 따라서 반복 실행을 계속할지 결정하는 경우에 사용

- break 문 : for문, whiel문, do-while문을 종료한다.(반복을 취소한다.)
	: switch문을 종료한다.

- continue문 : for문 while문, do-while문에서 사용한다.

----------------------------------------------
chapter 05 참조 타입
----------------------------------------------

5.1 데이터 타입 분류

자바의 데이터 타입에는 크게

1. 기본타입(원시 타입 : primitive type)
	: 정수, 실수, 문자, 논리 리터럴을 정하는 타입.
2. 참조타입(reference type) 
	: 객체(Object)으 ㅣ번지를 참조하는 타입으로
	  배열, 열거, 클래스, 인터페이스 타입.

으로 분류된다.

※ 참조타입은 메모리의 번지를 값으로 갖는다.
  : 번지를 통해 객체를 참조한다는 뜻에서 참조타입이라고 부른다.

비고.
int와 double 변수는 직접 값을 저장하고 있지만,
String 클래스 변수는 힙 영역의 String 객체 주소 값을 가지고 있다.

----------------------------------------------

5.2 메모리 사용 영역

JVM은 OS에서 할당받은 몌모리 영역(Runtime Data Area)을 세 영역으로 구분한다.
- 메소드 영역 : 클래스 코드들이 있다.
- 힙 영역 : 객체가 생성된다.
- JVM 스택 : 변수들이 생성된다.

■ 메소드 영역
	- JVM을 시작할 때 생성
	- 로딩된 클래스 바이트 코드 내용을 분석후 저장
	- 모든 스레드가 공유
■ 힙 영역
	- JVM을 시작할 때 생성
	- 객체/배열 저장
	- 사용되지 않는 객체는 쓰레기 수집기(Garbage Collector)가 자동 제거

■ JVM 스택
	- 스레드별로 생성
	- 메소드를 호출할 때마다 Frame을 스택에 추가(push)
	- 메소드가 종료하면 Frame을 제거(pop)

----------------------------------------------

5.3 참조 변수의 ==, != 연산

변수의 값이 같은지 비교
-> 기본타입 : byte, char, short, int, long, float, double, boolean
	: 변수의 값이 같은지 다른지 조사

-> 참조타입 : 배열, 열거, 클래스, 인터페이스
	: 동일한 "객체"를 참조하는지 다른 "객체"를 참조하는지 조사

----------------------------------------------

5.4 null과 NullPointerException

■ null(널)
  - 변수가 참조하는 객체가 없을 경우 초기값으로 사용 가능
  - 참조 타입의 변수에만 저장 가능
  - null로 초기화된 참조 변수는 스택 영역 생성
  - ==, != 연산이 가능

■ NullPointerException
  - 예외(Exception)
	: 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류
  - NullPointerException
	: 참조 변수가 null 값을 가지고 있을 때,
	  객체의 필드나 메소드를 사용하려고 했을 때 발생한다.
  ex)
	String str = null;
	System.out.println(str.length());
	> NullPointerException

----------------------------------------------

5.5 String 타입

■ String 타입
  - 문자열을 저장하는 클래스 타입
  - 문자열 리터럴이 동일하다면 String 객체를 공유한다.
  - new 연산자를 이용한 객체 생성
	: 힙 영역에 새로운 String 객체를 생성
	: String 객체를 생성한 후 번지를 리턴
  - 문자열 비교
  	: 비교연산자 == 를 사용하면 객체 비교
	: equals() 메소드 를 사용하면 문자열 비교
	ex) String name1 = "신용권";
	    String name2 = "신용권";
	    String name3 = new String("신용권");

	name1 == name2 		// true
	name2 == name3 		// false
	name2.equals(name3)	// true

■ 참조를 잃은 String 객체는
  : 쓰레기 수집기(Garbage Collector)를 구동시켜 메모리에서 자동 제거된다.
	(아래와 같은 경우 위 설명)
	String hobby = "여행"
	hoppy = null;

----------------------------------------------

5.6 배열 타입

■ 배열이란
  - 같은 타입의 데이터를 연속된 공간에 저장하는 자료구조
  - 각 데이터 저장 위치는 인덱스를 부여해서 접근할 수 있다.
  - 배열의 필요성
	: 중복된 변수 선언을 줄이기 위해 사용된다.
	: 반복문을 이용해서 요소들을 쉽게 처리하기 위해

■ 배열선언
  - 배열을 사용하기 위해서는 우선 배열 변수를 선언해야 한다.
    : 타입[] 변수;
	int[] intArray;
	double[] doubleArray;
	String[] strArrayy;

  - 배열 변수는 참조 변수이므로 배열이 생성되기 전에 null로 초기화가 가능하다.
    : 타입[] 변수 = null
	- 배열 변수가 null값을 가진 상태에서 항목에 접근하기 위해
	  "변수[인덱스]" 는 못한다.

■ 값 목록으로 배열 생성
  - 변수 선언과 동시에 값 목록을 대입
    : 데이터타입[] 변수 = {값0, 값1, 값2 ... };
	※ 데이터타입에 맞는 인덱스가 들어있어야 한다.

  - 변수 선언후에 값 목록을 대입
    : 데이터타입[] 변수;
	 변수 = new 타입[] { 값0, 값1, 값2, ...}
	※ 변수를 먼저 선언하고 대입할 때에는 new 연산자를 붙여줘야한다.
	: 배열을 매개변수로 가지는 매소드를 호출할 때,
	  배열을 직접 생성해서 매개값으로 줄 경우

■ new 연산자로 배열 생성
  - 배열 생성시 값 목록을 가지고 있지 않고
    향후 값들을 저장할 배열을 미리 생성하고 싶은 경우
	: 타입[] 변수 = new 타입[길이];

	: 타입[] 변수 = null;
	  변수 = new 타입[길이]
	ex) int[] intArray = new int[5];

  - 항목의 기본값
	: 기본타입 -> 0으로 초기화
	: 실수타입 -> 0.0
	: 논리타입 -> false
	: 참조타입 -> null

■ 배열의 길이
  - 배열에 저장할 수 있는 전체 항목 수
  - 코드에서 배열의 길이를 얻는 방법
	ex) 배열변수.length;
		: int[] intArray = {10,20,30}
		  int num = intArray.length;  -> 3
  - 배열의 길이는 읽기전용이다.
	ex) 잘못된 코드 -> intArray.length = 10;
  - 배열의 길이는 for문의 조건식에서 주로 사용된다.

■ 커멘드 라인 입력
  - java 클래스로 프로그램을 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고
    main()메소드를 호출할 때 매개값으로 전달한다.

■ 다차원 배열
  - 2차원 배열 이상을 다차원 배열이라고 한다.
  - 2차원 배열은 수학의 행렬과 같은 자료 구조이다.
  - 자바는 1차원 배열을 이용해서 2차원 배열을 구현한다.
	ex) int[][] scores =new int[2][3]

  - 계단식 구조의 2차원 배열
	: 수학의 행렬 구조를 가지지 않음

	int[][] scores = new int[2][];	// 배열 A |0|1|
	scores[0] = new int[2];		// 배열 B |0|1|
	scores[1] = new int[3];		// 배열 C |0|1|2|

	scores.length		// 2	(배열 A의 길이)
	scores[0].length	// 2 (배열 B의 길이)
	scores[1].length	// 3 (배열 C의 길이)

  - 값 목록을 이용한 2차원 배열

	int[][] scores = { {95,80}, {92,96} };
	int score1 = scores[0][0];	// 95(0번쨰의 0번쨰)
	int score2 = scores[1][1];	// 96(1번쨰의 1번째)

	String[][] names = {
	{ "AA", "BB", "CC" },
	{ "aa", "bb", "cc" }
	};
	
	String name1 = names[0][1];	// BB
	String name2 = names[1][2];	// cc

■ 객체를 참조하는 배열
  - 기본 타입(byte, char, short, int, long, float, double, boolean) 배열
	: 각 항목에 직접 "값"을 가지고 있다.
  - 참조 타입(클래스, 인터페이스) 배열
	: (참조 변수처럼)각 항목에 객체의 번지를 가지고 있다.

	String[] strArray = new String[3];
	strArray[0] = "Java";
	strArray[1] = "Java";
	strArray[2] = new String("Java");

	strArray[0] == strArray[1];	// true  (같은 객체 참조)
	strArray[0] == strArray[2];	// flase (다른 객체 참조)
	strArray[0].equals(strArray[2])	// true  (문자열이 동일)

■ 배열 복사
  - 배열은 한 번 생성하면 크기를 변경할 수 없다.
  - 더 많은 저장 공간이 필요하다면 보다 큰 배열을 새로 만들고
    이전 배열로부터 항목 값들을 복사해야 한다.
  - 배열 복사 방법
	- for문으로 배열 복사
	- System.arraycopy() 메소드 사용

■ 향상된 for문
  - 배열 및 컬렉션의 항목요소를 순차적으로 처리
  - 인덱스를 이용하지 않고 바로 항목 요소를 반복
  - 자바5부터 지원

	int[] scores = {95, 71, 84, 93, 87};
	
	int sum = 0;
	// 향상된 for문
	for(int score : scores) {	
	sum = sum + score;
	}

	// 일반 for문
	for(int i=0; i<scores.length; i++ {
	sum = sum + score;
	}

----------------------------------------------

5.7 열거 타입

■ 열거타입(Enumeration Type)
  - 한정된 값만을 갖는 데이터 타입
  - 한정된 값은 열거 상수(Enumeration Constant)로 정의

■ 열거 타입 선언
  - 열거 타입 소스 파일 생성 : ~.java
	- 열거타입 이름의 첫 문자는 대문자로 작성(관례)
  - 소스 작성 방법
	- 파일 이름과 동일한 이름으로 선언
	  : public enum 열거타입이름 {...}
 	- 한정된 값의 열거 상수 정의
	  - 열거 상수 이름은 관례적으로 모두 대문자로 작성한다.
	  - 다른 언어가 결합된 이름일 경우 관례적으로 밑줄(_)로 연결

■ 열거 타입 변수
  - 열거 타입 변수 선언
	ex) 열거타입 변수;
  - 열거 상수값 저장
	- 열거 타입 변수값은 열거 상수 중 하나이어야 한다.
	ex) 열거타입 변수 = 열거타입.열거상수;
  - 열거 타입 변수는 참조 타입
	- 열거 타입 변수는 참조 타입이므로 null 값을 저장할 수 있다.
  - 열거 상수는 열거 객체를 참조한다.
	- 열거 객체는 힙에 생성된다.
	- 열거 상수는 메소드 영역에서 열거 객체를 참조한다.

■ 열거 객체의 메소드
  - 열거 객체는 열거 상수의 문자열을 내부 데이터로 가지고 있다.
  - 열거 타입은 컴파일시에 java.lang.Enum 클래스를 자동 상속한다.
    : 열거 객체는 java.lang.Enum 클래스의 메소드를 사용할 수 있다.

ex)
● name() 메소드
: 아래는 name()메소드를 호출하여 문자열을 얻는다.

Week today = Week.SUNDAY;
String name = today.name();

● Oridinal() 메소드
: 전체 열거 객체 중 몇 번째 열거 객체인지 알려준다.

Week.today = Week.SUNDAY;
int ordinal = today.ordinal();

● CompareTo() 메소드
: 위치 차이를 숫자로 리턴한다.

Week day1 = Week.MONDAY;	// 0
Week day2 = Week.WENDSDAY;	// 2
int result1 = day1.CompareTo(day2);  //0-2= -2
int result2 = day2.CompareTo(day1);  //2-0=  2

● valueOf()메소드
: 매개값으로 주어지는 문자열과 동일한 문자열을 가지는
  열거 객체를 리턴한다.
: 아래는 weekDay 변수는 Week.SATURDAY 열거 객체를 참조한다.

Week weekDay = Week.valueOf("SATURDAY");

● values()메소드
: 열거 타입의 모든 열거 객체들을 배열로 만들어 리턴한다.
: 아래는 Week 열거 타입의 모든 열거 객체를 배열로 만들어
  향상된 for문을 이용해서 반복하는 코드이다.
  
Week[] days = Week.values();
for(Week day : days){
	System.out.println(day);
}

----------------------------------------------
chapter 05 참조 타입
----------------------------------------------

6.1 객체 지향 프로그래밍

■ 객체 지향 프로그래밍
- OOP : Object Oriented Programming
- 부품 객체를 먼저 만들고 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법

■ 객체(Object)란?
- 물리적으로 존재하거나, 추상적인 것 중 자신의 속성과 동작을 가지는 모든 것
- 객체는 필드(속성)과 메소드(동작)로 구성된 자바 객체로 모델링할 수 있다.

■ 객체의 상호작용
- 객체들은 서로 간에 기능(동작)을 이용하고 데이터를 주고 받는다.
- 자바의 객체도 서로 간에 메소드를 호출하고 결과를 받는다.

■ 객체간의 관계
- 객체 지향 프로그램에서는 객체는 다른 객체와 관계를 맺고 있다.
- 관계의 종류
	- 집합관계 : 완성품과 부품의 관계
	- 사용관계 : 객체가 다른 객체를 사용하는 관계
	- 상속 관계 : 조율 객체와 구체적인 사물 객체 관계

■ 객체 지향 프로그래밍 특징(캡슐화, 상속, 다향성)
● 캡슐화
- 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것
- 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
- 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해
	객체가손상되지 않도록 하는데 있다.
- 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결과하기 위해 '접근 제한자'를 사용한다.

● 상속
- 상위(부모) 객체의 필드와 메소드를 하위(자식) 객체에게 물려주는 행위
- 하위 객체는 상위 객체를 확장해서 추가적인 피륻와 메소드를 가질 수 있다
- 상속 대상 : 필드와 메소드

- 상속의 효과
	- 상위 객체를 재사용해서 하위 객체를 빨리 개발할 수 있다.
	- 반복된 코드의 중복을 줄여준다
	- 유지 보수의 편리성을 제공해 준다.
	- 객체의 다형성을 구현할 수 있다.

● 다형성(Polymorphism)
- 같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질을 말한다.
	- 효과 : 객체를 부품화시킬 수 있다.
		   : 유지 보수가 용이하다.

----------------------------------------------
