----------------------------------------------
chapter 02 변수와 타입
----------------------------------------------

2.1 변수

변수란
- 하나의 값을 저장할 수 있는 메모리 공가닝다.
- 변수의 첫 번째 글자는 문자이거나 $ _ 이어야 하며
  숫자로 시작할 수 없다.
- 선언된 블록 내에서만 사용이 가능하다.

----------------------------------------------

2.2 데이터 타입

정수 타입 : byte, char, shortm int, long
실수 타입 : float, double
논리 타입 : boolean

자바는 기본적으로 정수 연산을 int 타입으로 실행한다.

String
- 클래스 타입이고, String 변수는 참조 변수이다.
- 문자열 String 변수에 대입하면 String 객체가 생성되고,
  String 변수는 String 객체의 번지를 참조하게 된다.

----------------------------------------------

2.3 타입 변환

■ 타입 변환
데이터 타입을 다른 데이터 타입으로 변환하는 것을 말한다.

■ 자동 타입 변환
  : 프로그램 실행 도중에 작은 타입은 큰 타입으로 자동 타입 변환된다.

■ 강제 타입 변환(캐스팅 : Casting)
  : 큰 타입을 작은 타입 단위로 쪼개고 끝 한부분만 작은 타입으로 강제적 변환한다.
	ex) 작은 크기 타입 = (작은크기타입) 큰 크기 타입
	ex)
	long longValue = 300;
	int intValue = (int)long Value;	// 정상 저장이 된다.

■ 연산식에서 자동 타입 변환
  : 연산은 같은 타입의 피연산자(operand)간에만 수행한다.
	- 서로 다른 타입의 피연산자는 같은 타입으로 변환됨.
	- 두 피연산자 중 크기가 큰 타입으로 자동 변환

----------------------------------------------
chapter 03 연산자
----------------------------------------------

3.1 연산자와 연산식

연산
- 데이터를 처리하여 결과를 산출하는 것
- 연산자(Operations) : 연산에 사용되는 표시나 기호
- 피연산자(Operand) : 연산 대상이 되는 데이터(리터럴, 변수)
- 연산식(Expression) : 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것

----------------------------------------------

3.2 연산의 방향과 우선순위

■ 우선 순위 정리
1. 단항, 이항, 삼항 연산자 순으로 우선순위를 가진다.
2. 산술, 비교, 논리, 대입 여산자 순으로 우선순위를 가진다.
3. 단항과 대입 연산자르 제외한 모든 연산자의 방향은 왼쪽에서 오른쪽이다.
4. 복잡한 연산식에는 괄호()사용해서 우선순위를 정해준다.

----------------------------------------------

3.3 단항 연산자

■ 단항 연산자
  : 피연산자가 1개인 연산자
- 종류
	- 부호 연산자 : ++
	- 증감 연산자 : ++, --
	- 부정 연산자 : !
	- 비트 반전 연산자 : ~

----------------------------------------------

3.4 이항 연산자

■ 이항 연산자
  : 피연산자가 2개인 연산자
- 종류
	- 산술 연산자 : +, - *, /, %
	- 문자열 연결 연산자 : +
	- 대입 연산자 : =, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=
	- 비교 연산자 : <, <=, >, >=, ==, !=
	- 논리 연산자 : &&, ||, &, |, ^, !
	
	■ 비트 연산자
	: 비트(bit)단위로 연산을 한다. 즉 0과 1이 피연산자가 된다.
	- 비트 논리 연산자 : &, |, ^
	- 비트 이동 연산자 : <<, >>, >>>

- 오버플로우
  : 산술 연산을 할 때에는 산출값이 산출 타입으로 충분히 표현 가능한지 살펴봐야 한다.

- 정확한 계산은 정수를 사용한다.

- String 타입의 문자열을 비교할 때에는 대소 연산자를 사용할 수 없다.
- 문자열 비교는  equals() 메소드를 사용해야 한다.

----------------------------------------------

3.5 삼항 연산자

조건 연산식( ()? : )
	조건식	 ? 	값 또는 연산식	:	값 또는 연산식
	(피연산자1) 	(피연산자2)		 (피연산자3)

----------------------------------------------
chapter 04 조건문과 반복문
----------------------------------------------

4.1 코드 실행 제어

■ 정상적인 코드 실행 흐름
  : main() 메소드의 시작 중괄호 {에서 끝 중괄호 }까지
    위에서 아래 방향으로 실행

■ 제어문의 역할
  : 정상적인 코드 실행 흐름을 개발자가 원하는 방향으로 변경할 수 있도록 한다.

■ 제어문의 종류
	1) 조건문 : if문, switch문
	2) 반복문	: for문, while문, do-while문
	3) break문, continue문

----------------------------------------------

4.2 조건문(if문, switch문)

■ if문
  : 조건식의 결과에 따라 중괄호 {} 블록을 실행할지 여부를 결정할 때 사용

■ if-else문
  : 조건식의 결과에 다라 실행 블록을 선택한다.

■ if-else if-else문
  : 복수의 조건식을 두어 조건식을 만족하는 블록만 실행한다.

■ 중첩 if문
  : if문의 블록 내부에는 또 다른 if문을 사용할 수 있다.

■ switch문
  : 변수나 연산식의 값에 따라 실행문을 선택할 때 사용한다.

----------------------------------------------

4.3 반복문(for문, while문, do-while문)

■ 반복문
  : 중괄호 블록 내용을 반복적으로 실행할 때 사용한다.

- for 문 : 반복 횟수를 알고 있을 때 주로 사용

- while 문 : 조건에 따라 반복을 계속할지를 결정할 때 사용

- do-while문 : 블록 내부의 실행문을 우선 실행하고
  실행 결과에 따라서 반복 실행을 계속할지 결정하는 경우에 사용

- break 문 : for문, whiel문, do-while문을 종료한다.(반복을 취소한다.)
	: switch문을 종료한다.

- continue문 : for문 while문, do-while문에서 사용한다.

----------------------------------------------
chapter 05 참조 타입
----------------------------------------------

5.1 데이터 타입 분류

자바의 데이터 타입에는 크게

1. 기본타입(원시 타입 : primitive type)
	: 정수, 실수, 문자, 논리 리터럴을 정하는 타입.
2. 참조타입(reference type) 
	: 객체(Object)으 ㅣ번지를 참조하는 타입으로
	  배열, 열거, 클래스, 인터페이스 타입.

으로 분류된다.

※ 참조타입은 메모리의 번지를 값으로 갖는다.
  : 번지를 통해 객체를 참조한다는 뜻에서 참조타입이라고 부른다.

비고.
int와 double 변수는 직접 값을 저장하고 있지만,
String 클래스 변수는 힙 영역의 String 객체 주소 값을 가지고 있다.

----------------------------------------------

5.2 메모리 사용 영역

JVM은 OS에서 할당받은 몌모리 영역(Runtime Data Area)을 세 영역으로 구분한다.
- 메소드 영역 : 클래스 코드들이 있다.
- 힙 영역 : 객체가 생성된다.
- JVM 스택 : 변수들이 생성된다.

■ 메소드 영역
	- JVM을 시작할 때 생성
	- 로딩된 클래스 바이트 코드 내용을 분석후 저장
	- 모든 스레드가 공유
■ 힙 영역
	- JVM을 시작할 때 생성
	- 객체/배열 저장
	- 사용되지 않는 객체는 쓰레기 수집기(Garbage Collector)가 자동 제거

■ JVM 스택
	- 스레드별로 생성
	- 메소드를 호출할 때마다 Frame을 스택에 추가(push)
	- 메소드가 종료하면 Frame을 제거(pop)

----------------------------------------------

5.3 참조 변수의 ==, != 연산

변수의 값이 같은지 비교
-> 기본타입 : byte, char, short, int, long, float, double, boolean
	: 변수의 값이 같은지 다른지 조사

-> 참조타입 : 배열, 열거, 클래스, 인터페이스
	: 동일한 "객체"를 참조하는지 다른 "객체"를 참조하는지 조사

----------------------------------------------

5.4 null과 NullPointerException

■ null(널)
  - 변수가 참조하는 객체가 없을 경우 초기값으로 사용 가능
  - 참조 타입의 변수에만 저장 가능
  - null로 초기화된 참조 변수는 스택 영역 생성
  - ==, != 연산이 가능

■ NullPointerException
  - 예외(Exception)
	: 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류
  - NullPointerException
	: 참조 변수가 null 값을 가지고 있을 때,
	  객체의 필드나 메소드를 사용하려고 했을 때 발생한다.
  ex)
	String str = null;
	System.out.println(str.length());
	> NullPointerException

----------------------------------------------

5.5 String 타입

■ String 타입
  - 문자열을 저장하는 클래스 타입
  - 문자열 리터럴이 동일하다면 String 객체를 공유한다.
  - new 연산자를 이용한 객체 생성
	: 힙 영역에 새로운 String 객체를 생성
	: String 객체를 생성한 후 번지를 리턴
  - 문자열 비교
  	: 비교연산자 == 를 사용하면 객체 비교
	: equals() 메소드 를 사용하면 문자열 비교
	ex) String name1 = "신용권";
	    String name2 = "신용권";
	    String name3 = new String("신용권");

	name1 == name2 		// true
	name2 == name3 		// false
	name2.equals(name3)	// true

■ 참조를 잃은 String 객체는
  : 쓰레기 수집기(Garbage Collector)를 구동시켜 메모리에서 자동 제거된다.
	(아래와 같은 경우 위 설명)
	String hobby = "여행"
	hoppy = null;

----------------------------------------------

5.6 배열 타입

■ 배열이란
  - 같은 타입의 데이터를 연속된 공간에 저장하는 자료구조
  - 각 데이터 저장 위치는 인덱스를 부여해서 접근할 수 있다.
  - 배열의 필요성
	: 중복된 변수 선언을 줄이기 위해 사용된다.
	: 반복문을 이용해서 요소들을 쉽게 처리하기 위해

■ 배열선언
  - 배열을 사용하기 위해서는 우선 배열 변수를 선언해야 한다.
    : 타입[] 변수;
	int[] intArray;
	double[] doubleArray;
	String[] strArrayy;

  - 배열 변수는 참조 변수이므로 배열이 생성되기 전에 null로 초기화가 가능하다.
    : 타입[] 변수 = null
	- 배열 변수가 null값을 가진 상태에서 항목에 접근하기 위해
	  "변수[인덱스]" 는 못한다.

■ 값 목록으로 배열 생성
  - 변수 선언과 동시에 값 목록을 대입
    : 데이터타입[] 변수 = {값0, 값1, 값2 ... };
	※ 데이터타입에 맞는 인덱스가 들어있어야 한다.

  - 변수 선언후에 값 목록을 대입
    : 데이터타입[] 변수;
	 변수 = new 타입[] { 값0, 값1, 값2, ...}
	※ 변수를 먼저 선언하고 대입할 때에는 new 연산자를 붙여줘야한다.
	: 배열을 매개변수로 가지는 매소드를 호출할 때,
	  배열을 직접 생성해서 매개값으로 줄 경우

■ new 연산자로 배열 생성
  - 배열 생성시 값 목록을 가지고 있지 않고
    향후 값들을 저장할 배열을 미리 생성하고 싶은 경우
	: 타입[] 변수 = new 타입[길이];

	: 타입[] 변수 = null;
	  변수 = new 타입[길이]
	ex) int[] intArray = new int[5];

  - 항목의 기본값
	: 기본타입 -> 0으로 초기화
	: 실수타입 -> 0.0
	: 논리타입 -> false
	: 참조타입 -> null

■ 배열의 길이
  - 배열에 저장할 수 있는 전체 항목 수
  - 코드에서 배열의 길이를 얻는 방법
	ex) 배열변수.length;
		: int[] intArray = {10,20,30}
		  int num = intArray.length;  -> 3
  - 배열의 길이는 읽기전용이다.
	ex) 잘못된 코드 -> intArray.length = 10;
  - 배열의 길이는 for문의 조건식에서 주로 사용된다.

■ 커멘드 라인 입력
  - java 클래스로 프로그램을 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고
    main()메소드를 호출할 때 매개값으로 전달한다.

■ 다차원 배열
  - 2차원 배열 이상을 다차원 배열이라고 한다.
  - 2차원 배열은 수학의 행렬과 같은 자료 구조이다.
  - 자바는 1차원 배열을 이용해서 2차원 배열을 구현한다.
	ex) int[][] scores =new int[2][3]

  - 계단식 구조의 2차원 배열
	: 수학의 행렬 구조를 가지지 않음

	int[][] scores = new int[2][];	// 배열 A |0|1|
	scores[0] = new int[2];		// 배열 B |0|1|
	scores[1] = new int[3];		// 배열 C |0|1|2|

	scores.length		// 2	(배열 A의 길이)
	scores[0].length	// 2 (배열 B의 길이)
	scores[1].length	// 3 (배열 C의 길이)

  - 값 목록을 이용한 2차원 배열

	int[][] scores = { {95,80}, {92,96} };
	int score1 = scores[0][0];	// 95(0번쨰의 0번쨰)
	int score2 = scores[1][1];	// 96(1번쨰의 1번째)

	String[][] names = {
	{ "AA", "BB", "CC" },
	{ "aa", "bb", "cc" }
	};
	
	String name1 = names[0][1];	// BB
	String name2 = names[1][2];	// cc

■ 객체를 참조하는 배열
  - 기본 타입(byte, char, short, int, long, float, double, boolean) 배열
	: 각 항목에 직접 "값"을 가지고 있다.
  - 참조 타입(클래스, 인터페이스) 배열
	: (참조 변수처럼)각 항목에 객체의 번지를 가지고 있다.

	String[] strArray = new String[3];
	strArray[0] = "Java";
	strArray[1] = "Java";
	strArray[2] = new String("Java");

	strArray[0] == strArray[1];	// true  (같은 객체 참조)
	strArray[0] == strArray[2];	// flase (다른 객체 참조)
	strArray[0].equals(strArray[2])	// true  (문자열이 동일)

■ 배열 복사
  - 배열은 한 번 생성하면 크기를 변경할 수 없다.
  - 더 많은 저장 공간이 필요하다면 보다 큰 배열을 새로 만들고
    이전 배열로부터 항목 값들을 복사해야 한다.
  - 배열 복사 방법
	- for문으로 배열 복사
	- System.arraycopy() 메소드 사용

■ 향상된 for문
  - 배열 및 컬렉션의 항목요소를 순차적으로 처리
  - 인덱스를 이용하지 않고 바로 항목 요소를 반복
  - 자바5부터 지원

	int[] scores = {95, 71, 84, 93, 87};
	
	int sum = 0;
	// 향상된 for문
	for(int score : scores) {	
	sum = sum + score;
	}

	// 일반 for문
	for(int i=0; i<scores.length; i++ {
	sum = sum + score;
	}

----------------------------------------------

5.7 열거 타입

■ 열거타입(Enumeration Type)
  - 한정된 값만을 갖는 데이터 타입
  - 한정된 값은 열거 상수(Enumeration Constant)로 정의

■ 열거 타입 선언
  - 열거 타입 소스 파일 생성 : ~.java
	- 열거타입 이름의 첫 문자는 대문자로 작성(관례)
  - 소스 작성 방법
	- 파일 이름과 동일한 이름으로 선언
	  : public enum 열거타입이름 {...}
 	- 한정된 값의 열거 상수 정의
	  - 열거 상수 이름은 관례적으로 모두 대문자로 작성한다.
	  - 다른 언어가 결합된 이름일 경우 관례적으로 밑줄(_)로 연결

■ 열거 타입 변수
  - 열거 타입 변수 선언
	ex) 열거타입 변수;
  - 열거 상수값 저장
	- 열거 타입 변수값은 열거 상수 중 하나이어야 한다.
	ex) 열거타입 변수 = 열거타입.열거상수;
  - 열거 타입 변수는 참조 타입
	- 열거 타입 변수는 참조 타입이므로 null 값을 저장할 수 있다.
  - 열거 상수는 열거 객체를 참조한다.
	- 열거 객체는 힙에 생성된다.
	- 열거 상수는 메소드 영역에서 열거 객체를 참조한다.

■ 열거 객체의 메소드
  - 열거 객체는 열거 상수의 문자열을 내부 데이터로 가지고 있다.
  - 열거 타입은 컴파일시에 java.lang.Enum 클래스를 자동 상속한다.
    : 열거 객체는 java.lang.Enum 클래스의 메소드를 사용할 수 있다.

ex)
● name() 메소드
: 아래는 name()메소드를 호출하여 문자열을 얻는다.

Week today = Week.SUNDAY;
String name = today.name();

● Oridinal() 메소드
: 전체 열거 객체 중 몇 번째 열거 객체인지 알려준다.

Week.today = Week.SUNDAY;
int ordinal = today.ordinal();

● CompareTo() 메소드
: 위치 차이를 숫자로 리턴한다.

Week day1 = Week.MONDAY;	// 0
Week day2 = Week.WENDSDAY;	// 2
int result1 = day1.CompareTo(day2);  //0-2= -2
int result2 = day2.CompareTo(day1);  //2-0=  2

● valueOf()메소드
: 매개값으로 주어지는 문자열과 동일한 문자열을 가지는
  열거 객체를 리턴한다.
: 아래는 weekDay 변수는 Week.SATURDAY 열거 객체를 참조한다.

Week weekDay = Week.valueOf("SATURDAY");

● values()메소드
: 열거 타입의 모든 열거 객체들을 배열로 만들어 리턴한다.
: 아래는 Week 열거 타입의 모든 열거 객체를 배열로 만들어
  향상된 for문을 이용해서 반복하는 코드이다.
  
Week[] days = Week.values();
for(Week day : days){
	System.out.println(day);
}

----------------------------------------------
chapter 05 참조 타입
----------------------------------------------

6.1 객체 지향 프로그래밍

■ 객체 지향 프로그래밍
- OOP : Object Oriented Programming
- 부품 객체를 먼저 만들고 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법

■ 객체(Object)란?
- 물리적으로 존재하거나, 추상적인 것 중 자신의 속성과 동작을 가지는 모든 것
- 객체는 필드(속성)과 메소드(동작)로 구성된 자바 객체로 모델링할 수 있다.

■ 객체의 상호작용
- 객체들은 서로 간에 기능(동작)을 이용하고 데이터를 주고 받는다.
- 자바의 객체도 서로 간에 메소드를 호출하고 결과를 받는다.

■ 객체간의 관계
- 객체 지향 프로그램에서는 객체는 다른 객체와 관계를 맺고 있다.
- 관계의 종류
	- 집합관계 : 완성품과 부품의 관계
	- 사용관계 : 객체가 다른 객체를 사용하는 관계
	- 상속 관계 : 조율 객체와 구체적인 사물 객체 관계

■ 객체 지향 프로그래밍 특징(캡슐화, 상속, 다향성)
● 캡슐화
- 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것
- 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.
- 필드와 메소드를 캡슐화하여 보호하는 이유는 외부의 잘못된 사용으로 인해
	객체가손상되지 않도록 하는데 있다.
- 자바 언어는 캡슐화된 멤버를 노출시킬 것인지 숨길 것인지를 결과하기 위해 '접근 제한자'를 사용한다.

● 상속
- 상위(부모) 객체의 필드와 메소드를 하위(자식) 객체에게 물려주는 행위
- 하위 객체는 상위 객체를 확장해서 추가적인 피륻와 메소드를 가질 수 있다
- 상속 대상 : 필드와 메소드

- 상속의 효과
	- 상위 객체를 재사용해서 하위 객체를 빨리 개발할 수 있다.
	- 반복된 코드의 중복을 줄여준다
	- 유지 보수의 편리성을 제공해 준다.
	- 객체의 다형성을 구현할 수 있다.

● 다형성(Polymorphism)
- 같은 타입이지만 실행 결과가 다양한 객체를 대입할 수 있는 성질을 말한다.
	- 효과 : 객체를 부품화시킬 수 있다.
		   : 유지 보수가 용이하다.

----------------------------------------------

6.2 객체와 클래스

■ 객체(Object)와 클래스(Class) 
- 현실세계 : 설계도 -> 객체
- 자바 : 클래스 -> 객체
- 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다
- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance) 라고 한다.
- 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있다.

----------------------------------------------

6.3 클래스 선언

■ 클래스의 이름
- 자바 식별자 작성 규칙에 따라야 한다.
	- 하나 이상의 문자로 이루어져야 한다.
	- 첫 번쨰 글자는 숫자가 올 수 없다.
	- $ _ 외의 특수 문자는 사용할 수 없다.
	- 자바 키워드는 사용할 수 없다.
- 한글 이름도 가능하나, 영어 이름으로 작성한다.
- 알파벳 대소문자는 서로 다른 문자로 인식한다.
- 첫자와 연결된 다른 단어의 첫자는 대문자로 작성하는 것이 관례다

■ 클래스 선언과 컴파일
- 소스 파일 생성 : 클래스 이름.java(대소문자 주의)
- 소스 작성
	-----------------------
	public class 클래스 이름 {

	}
	-----------------------
- 소스 파일당 하나의 클래스를 선언한 것이 관례지만 두 개 이사의 클래스도 선언이 가능하다.
	- 소스 파일 이름과 동일한 클래스의 public 으로 선언할 수 있다.
	- 선언한 개수만큼 바이트코드 파일이 생성된다.
		Car.java
		-----------------------
		public class Car {

		}
		-----------------------

----------------------------------------------

6.4 객체 생성과 클래스 변수

■ new 연산자로
- 객체를 생성하는 역할을 한다.
	new 클래스();
	- 클래스()는 생성자를 호출하는 코드이다.
	- 생성된 객체는 힙 메모리 영역에 생성된다.
- new 연산자는 객체를 생성한 후, 객체 생성 번지를 리턴한다.

■ 클래스 변수
- new 연산자에 의해 리턴된 객체의 번지를저장하는 변수(참조 타입 변수)다
- 힙 영역의 객체를 사용하기 위해 사용한다.
	클래스 변수;
	변수 = new 클래스();

	클래스 = new 클래스();

■ 클래스의 용도
- 라이브러리(API : Application Program Interface) 용
	: 자체적으로 실행되지 않으나, 다른 클래스에서 이용할 목적으로 만든 클래스
- 실행용
	: main()메소드를 가지고 있는 클래스로 실행할 목적으로 만든 클래스

1개의 애플리케이션 = (1개의 실행 클래스) + (n개의 라이브러리 클래스)

----------------------------------------------

6.5 클래스의 구성 멤버

■ 클래스의 구성 멤버
- 필드(Field)
- 생성자(Constructor)
- 메소드(Method)

● 필드(Field)
: 객체의 데이터가 저장되는 곳

● 생성자(Constructor)
: 객체 생성시 초기화 역할 담당

● 메소드(Method)
: 객체의 동작에 해당하는 실행 블록

※
생성자는 클래스 이름과 동일하고, 리턴타입이 없다.
메소드는 이름을 자유롭게 지정가능하고, 리턴타입이 필요하다.

----------------------------------------------

6.6 필드

■ 필드의 내용
- 객체의 고유 데이터
- 객체가 가져야 할 부품 객체
- 객체의 현재 상태 데이터

■ 필드 선언
 타입 필드 [= 초기값];

■ 필드의 기본 초기값
※ 초기값이 지정되지 않은 필드들은 객체 생성 시 자동으로 기본 초기값으로 설정된다.

■ 필드 사용
- 필드값을 읽고, 변경하는 작업
- 필드 사용 위치
	- 객체 내부 : "필드 이름"으로 바로 접근
	- 객체 외부 : "변수.필드이름"으로 접근

----------------------------------------------

6.7 생성자(1)

■ 생성자
: new 연산자에 의해 호출되어 객체의 초기화를 담당한다.
	new 클래스();
	- 필드의 값을 설정하거나
	- 메소드를 호출해서 객체를 사용할 수 있도록 준비하는 역할 수행

■ 기본 생성자(Default Constructor)
- 모든 클래스는 생성자가 반드시 존재하며 하나 이상을 가질 수 있다.
- 생성자 선언을 생략하면 컴파일러는 기본 생성자를 추가시킨다.

■ 생성자 선언
- 디폴트 생성자 대신 개발자가 직접 선언
	-------------------------------
	클래스 ( 매개변수선언, ...) {
		// 객체의 초기화 코드
	}
	-------------------------------
- 개발자가 선언한 생성자가 있을 경우, 컴파일러는 기본생성자를 추가하지 않는다.
	- new 연산자로 객체 생성시 개발자가 생성한 생성자를 반드시 사용해야 한다.
	-------------------------------
	public class Car {
		Car(String model, String color, int maxSpeed) {
			...
		}
	}
	-------------------------------
	Car myCar = new Car("그랜저", "검정", 300);
	-------------------------------

■ 필드 초기화
- 초기값 없이 선언된 필드는 객체가 새성될 때 기본값으로 자동 설정된다.
- 다른 값으로 필드를 초기화 하는 방법
	- 필드를 선언할 때 초기값을 설정
	- 생성자의 매개값으로 초기값을 설정

■ 생성자의 매개변수와 필드명이 동일할 경우

- 관례적으로 매개변수의 값을 필드값으로 설정할 경우 매개변수와 필드명을 동일하게 준다.
- 생성자 내부에서는 매개변수가 우선 순위를 갖는다.
- 필드임을 명시하기 위해 this.필드명을 사용한다.
	- this는 객체 자신의 참조로서 자신의 번지를 가지고 있다.
	------------------------------------------
	public Korean(String name, String ssn) {
		this.name = name;
		this.ssn = ssn;
	}
	------------------------------------------

----------------------------------------------

6.7 생성자(2)

■ 생성자를 다양화해야 하는 이유
- 객체를 생성할 떄 외부의 값으로 객체를 초기화할 필요가 있다.
- 외부의 값이 어떤 타입으로 몇 개가 제공될 지 모르기 때문에 생성자도 다양화해질 필요가 있다.

■ 생성자 오버로딩(Overloading)
- 매개변수의 타입, 개수, 순서가 다른 생성자를 여러 개 선언하는 것을 말한다.

■ 다른 생성자 호출 this()
- 초기화가 오버로딩 되면 생성자 간의 중복된 코드가 발생할 수 있다.
- 초기화 내용이 비슷한 생성자들에서 이런한 현상을 많이 볼 수 있다.

	● 해결 방법
	- 초기화 내용을 한 생성자에 몰아서 작성한다.
	- 다른 생성자는 초기화 내용을 작성한 생성자를 this()로 호출한다.
	※ this 호출은 반드시 첫쨰줄에 와야 한다.

----------------------------------------------

6.8 메소드(1)

■ 메소드란
- 개체의 동작(기능)을 말하며 호출해서 실행할 수 있는 중괄호 {} 블록
- 중괄호 블록은 이름을 가지고 있는데 이것이 메소드 이름이다.
- 메소드를 호출하면 중괄호 { }블록에 있는 모든 코드들이 일괄적으로 실행된다.

리턴타입 메소드이름( [매개변수선언, ...]) {
	실행할 코드를 작성하는 곳
}

■ 리턴 타입
- 메소드가 실행 후 리턴하는 값의 타입
- 메소드는 리턴값이 있을 수도 있고 없을 수도 있다.

■ 메소드 이름
- 자바 식별자 규칙에 맞게 작성하면 된다.
	- 숫자로 시작하면 안되고, $ 와 _를 제외한 특수문자는 사용하지 않는다.
	- 관례적으로 메소드명은 소문자로 작성한다.
	- 서로 다른 단어가 혼합된 이름이라면 뒤이어 오는 단어의 첫머리 글자는 대문자로 작성

■ 매개변수 선언
- 매개변수는 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용한다.
- 매개변수의 선언은 옵션이다.

■ 매개변수의 수를 모를 경우
방법1) 배열로 선언
	int sum1(int[] values){}

	int values = {1,2,3};
	int result = sum1(values);
	int result = sum1(new int[] {1,2,3,4,5});
방법2)
	int sum2(int ... values) {}		// ...을 사용한다.

	int result = sum2(1,2,3);
	int result = sum2(1,2,3,4,5);
	
----------------------------------------------

6.8 메소드(2)

■ 리턴(return) 문
- 메소드의 실행을 중지하고 리턴값을 지정하는 역할을 한다.
- 리턴값이 있는 메소드
	- 반드시 리턴(return)문을 사용해서 리턴값을 지정해야 한다.
	- return문 뒤에는 실행문이 올 수 없다.
- 리턴값이 없는 메소드 (void)
	- return 문은 옵션이며, return문의 용도는 메소드 실행을 단지 중지한다.

----------------------------------------------

6.8 메소드(3)

■ 메소드 호출(객체)
- 메소드는 클래스 내·외부의 호출에 의해 실행된다.
	- 클래스 내부 : 메소드 이름으로 호출
	- 클래스 외부 : 객체 생성 후, 참조 변수를 이용해서 호출

■ 객체 내부에서 호출
- 메소드의 이름으로 호추랗되 ,매개변수의 타입과 수에 맞게 매개값을 제공해야 한다.
- 리턴값이 없는 메소드(호출)

■ 객체 외부에서 호출
- 클래스로부터 객체를 생성하고 클래스 변수가 참조하도록 한다.
	클래스 참조변수 = new 클래스(매개값, ...);
- 참조변수와 함께 도트(.) 연산자를 이용해서 메소드를 호출한다.

■ 메소드 오버로딩(Overloading)
- 클래스 내에 많은 이름의 메소드를 여러 개 선언하는 것을 말한다.
- 하나의 메소드 이름으로 다양한 매개값을 받기 위해 메소드 오버로딩한다.
- 오버로딩의 조건 : 매개변수의 타입, 개수, 순서가 달라야 한다.

----------------------------------------------

6.9 인스턴스 멤버와 this

■ 인스턴스 멤버란
- 객체(인스턴스) 마다 가지고 있는 필드와 메소드를 말한다.
- 인스턴스 멤버는 객체에 소속된 멤버이기 때문에 객체가 없이는 사용할 수 없다.

■ this
- 객체(인스턴스) 자신의 참조(번지)를 가지고 있는 키워드이다.
- 객체 내부에서 인스턴스 멤버임을 명확히 하기 위해 this.를 붙일 수 있다.
- 주로 매개변수와 필드명이 동일할 경우 인스턴스 필드임을 명확히 하기 위해 붙인다.

----------------------------------------------

6.10 정적 멤버와 static(1)

■ 정적(static) 멤버란
- 정적 멤버란 클래스에 고정된 필드와 메소드를 말한다.
	- 이들을 각각 정적 필드, 정적 메소드라고 부른다.
- 정적 멤버는 클래스에 소속된 멤버로, 객체 내부에 존재하지 않고,
  메소드 영역에 존재한다.
  - 정적 멤버는 객체를 생성하지 않고 클래스로 바로 접근해서 사용한다.

■ 정적 멤버 선언
- 필드 또는 메소드를 선언할 때 static 키워드를 붙이면 된다.

■ 정적 멤버 사용
- 클래스 이름과 함께 도트(.) 연산자로 접근할 수 있다.

■ 인스턴스 멤버 선언 vs 정적 멤버 선언
- 필드
	- 객체마다 가지고 있어야 할 필드 : 인스턴스 필드
	- 공용적인 데이터 : 정적 필드
- 메소드
	- 인스턴스 필드로 작업해야할 메소드 : 인스턴스 메소드
	- 인스턴스 필드로 작업하지 않는 메소드 : 정적 메소드

■ 정적 초기화 블록
- 클래스가 메소드 영역으로 로딩될 때 자동으로 실행하는 블록이다.
	static {
		...
	}
- 정적 필드의 복잡한 초기화 작업과 정적 메소드를 호출할 수 있다.
- 클래스 내부에 여러 개가 선언되어도 상관없다. 선언된 순서대로 실행된다.

----------------------------------------------

6.11 정적 멤버와 static(2)

■ 정적 메소드와 정적 블록 작성시 주의할 점
- 객체가 없어도 실행할 수 있기 떄문에
  이들 블록 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.
- 객체 자신의 참조인 this를 사용할 수 없다.

■ main() 메소드도 정적 메소드이다.

■ 싱글톤(singleton)
- 하나의 애플리케이션 내에서 단 하나만 생성되는 객체를 말한다.

■ 싱글톤을 만드는 방법
- 외부에서 new 연산자로 생성자를 호출할 수 없도록 막는다.
	: private 접근 제한자를 생성자 앞에 붙인다.
- 클래스 자신의 타입으로 정적 필드를 선언하고, 자신의 객체를 생성해 초기화한다.
	: private 접근 제한자를 붙여 외부에서 필드값을 변경할 수 없도록 막는다.
- 외부에서 호출할 수 있는 정적 메소드인 getInstance()를 선언한다.
	: 정적 필드에서 참조하고 있는 자신의 객체를 리턴하도록 한다.

■ 싱글톤을 얻는 방법
	클래스 변수1 = 클래스.getInstance();
	클래스 변수2 = 클래스.getInstance();

----------------------------------------------

6.11 final 필드와 상수

■ final 필드
- 최종적인 값을 갖고 있는 필드 = 값을 변경할 수 없는 필드
- final 필드의 딱 한번의 초기값 지정 방법

■ 상수(static final)
- 상수 = 정적 final 필드
	- final 필드 : 객체마다 가지는 불변의 인스턴스 필드
	- 상수(static final) : 공용 데이터

■ 상수 선언과 초기화
- 상수 이름
	- 전부 대문자로 작성하는 것이 관례
	- 다른 단어가 결합되면 _로 연결하는 것이 관례

----------------------------------------------

6.12 패키지(1)

■ 패키지란
- 클래스를 기능별로 묶어서 그룹 이름을 붙여 놓은 것을 말한다.
	- 폴더(디렉터리)와 비슷한 개념이다.
	- 패키지의 물리적인 형태는 파일 시스템의 폴더이다.
- 클래스는 클래스 이름의 일부이다.
	- 전체 클래스 이름 = 상위패키지.하위클래스.클래스
	- 클래스명이 같아도 패키지명이 다르면 다른 클래스로 취급한다.
- 클래스를 선언할 때 패키지가 결정된다.
	- 클래스를 선언할 때 포함될 패키지를 선언해야 한다.
	- 클래스 파일은(~.class)는 선언된 패키지와 동일한 폴더안에서만 동작한다.
	- 클래스 파일은(~.class) 다른 폴더안에 넣으면 동작하지 않는다.

■ 클래스 선언
- 패키지 선언은 클래스 선언 첫 줄에 해야 한다.
- 상위 패키지와 하위 패키지는 도트(.)로 구분한다.

- 패키지이름 규칙
	- 알파벳 소문자로 작성하는 것이 관례
	- 숫자로 시작하면 안된다.
	- _와 $를 제외한 특수 문자를 사용해서는 안된다.
	- 회사 도메인의 역순으로 패키지 이름이 보통이다.

■ 패지지 선언이 포함된 클래스 컴파일
- 명령 라인에서 컴파일 할 경우
	- javac XXX.java
		- 바이트 코드 파일(~.class)만 생성되므로 패키지별로 폴더를 직접 만들어
		바이트 코드 파일을 저장하고 사용해야 한다.
	- javac -d [패키지가 생성될 위치] XXX.java
		- 패키지 폴더가 자동으로 생성된다.
	
- 패지지 선언이 포함된 클래스 실행
	- 상위(루트) 피키지가 시작하는 곳에서 실행해야 한다.
	- javac 상위피지.하위피키지.클래스

----------------------------------------------
